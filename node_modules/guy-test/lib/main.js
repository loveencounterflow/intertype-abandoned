// Generated by CoffeeScript 2.3.1
(function() {
  //###########################################################################################################
  var ASYNC, CND, DIFF, alert, badge, debug, diff, echo, help, info, is_callable, jr, log, njs_domain, rpr, urge, warn, whisper,
    splice = [].splice;

  njs_domain = require('domain');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'TEST';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  ASYNC = require('async');

  DIFF = require('diff');

  is_callable = function(x) {
    var ref;
    return (ref = Object.prototype.toString.call(x)) === '[object Function]' || ref === '[object AsyncFunction]';
  };

  ({jr} = CND);

  //-----------------------------------------------------------------------------------------------------------
  diff = function(a, b) {
    var color, i, len, part, parts, ref;
    parts = [];
    ref = DIFF.diffChars(a, b);
    for (i = 0, len = ref.length; i < len; i++) {
      part = ref[i];
      color = part.added ? 'green' : (part.removed ? 'red' : 'white');
      parts.push(CND[color](part.value));
    }
    return parts.join('');
  };

  // #===========================================================================================================
  // # TIMEOUT KEEPER
  // #-----------------------------------------------------------------------------------------------------------
  // call_with_timeout = ( timeout, test_name, method, P..., handler ) ->
  //   keeper_id = null
  //   #.........................................................................................................
  //   keeper = ->
  //     # clearTimeout keeper_id
  //     keeper_id = null
  //     warn "(test: #{rpr test_name}) timeout reached; proceeding with error"
  //     handler new Error "µ64748 sorry, timeout reached (#{rpr timeout}ms)"
  //   #.........................................................................................................
  //   keeper_id = setTimeout keeper, timeout
  //   #.........................................................................................................
  //   method P..., ( P1... ) ->
  //     if keeper_id?
  //       clearTimeout keeper_id
  //       keeper_id = null
  //       # help "(test: #{rpr test_name}) timeout cancelled; proceeding as planned"
  //       return handler P1...
  //     whisper "(test: #{rpr test_name}) timeout already reached; ignoring"

  //===========================================================================================================
  // TEST RUNNER
  //-----------------------------------------------------------------------------------------------------------
  module.exports = function(x, settings = null) {
    var new_result_handler_and_tester, report, run, stats;
    /* TAINT should accept a handler in case testing contains asynchronous functions */
    /* Timeout for asynchronous operations: */
    if (settings == null) {
      settings = {};
    }
    if (settings['timeout'] == null) {
      settings['timeout'] = 1000;
    }
    //.........................................................................................................
    stats = {
      'test-count': 0,
      'check-count': 0,
      'meta-count': 0,
      'pass-count': 0,
      'fail-count': 0,
      'failures': {}
    };
    //=========================================================================================================

    //---------------------------------------------------------------------------------------------------------
    new_result_handler_and_tester = function(test_name) {
      var RH, T, keeper_id;
      RH = {
        'name': test_name
      };
      T = {
        'name': test_name
      };
      keeper_id = null;
      //=======================================================================================================
      // TIMEOUT KEEPER
      //-------------------------------------------------------------------------------------------------------
      RH.call_with_timeout = function(timeout, method, ...P) {
        var handler, keeper, ref;
        ref = P, [...P] = ref, [handler] = splice.call(P, -1);
        //.....................................................................................................
        keeper = () => {
          // clearTimeout keeper_id
          keeper_id = null;
          warn(`(test: ${rpr(test_name)}) timeout reached; proceeding with error`);
          return handler(new Error(`µ65513 sorry, timeout reached (${rpr(timeout)}ms) (${rpr(test_name)})`));
        };
        //.....................................................................................................
        keeper_id = setTimeout(keeper, timeout);
        whisper(`started:   ${rpr(test_name)}`);
        //.....................................................................................................
        return method(...P, (...P1) => {
          if (keeper_id != null) {
            this.clear_timeout();
            return handler(...P1);
          }
          return whisper(`(test: ${rpr(test_name)}) timeout already reached; ignoring`);
        });
      };
      //-------------------------------------------------------------------------------------------------------
      RH.clear_timeout = function() {
        if (keeper_id != null) {
          // debug '©9XSyM', "clearing timeout for #{rpr test_name}"
          clearTimeout(keeper_id);
          keeper_id = null;
          return true;
        }
        return false;
      };
      //-------------------------------------------------------------------------------------------------------
      // COMPLETION / SUCCESS / ERROR
      //-------------------------------------------------------------------------------------------------------
      RH.on_completion = function(handler) {
        this.clear_timeout();
        whisper(`completed: ${rpr(test_name)}`);
        return handler();
      };
      //-------------------------------------------------------------------------------------------------------
      RH.on_success = function() {
        stats['pass-count'] += 1;
        return null;
      };
      //-------------------------------------------------------------------------------------------------------
      RH.on_error = function(delta, checked, error) {
        var entry, failures, ref;
        // @clear_timeout()
        stats['fail-count'] += +1;
        if (error == null) {
          delta += +1;
        }
        try {
          entry = CND.get_caller_info(delta, error, true);
        } catch (error1) {
          throw error;
        }
        if (entry == null) {
          throw error;
        }
        entry['checked'] = checked;
        entry['message'] = (ref = error != null ? error['message'] : void 0) != null ? ref : "µ66278 Guy-test: received `null` as error";
        failures = stats['failures'];
        (failures[test_name] != null ? failures[test_name] : failures[test_name] = []).push(entry);
        return null;
      };
      //-------------------------------------------------------------------------------------------------------
      // CHECKS
      //-------------------------------------------------------------------------------------------------------
      T.eq = function(...P) {
        var message, p;
        /* Tests whether all arguments are pairwise and deeply equal. Uses CoffeeNode Bits'n'Pieces' `equal`
        for testing as (1) Node's `assert` distinguishes—unnecessarily—between shallow and deep equality, and,
        worse, [`assert.equal` and `assert.deepEqual` are broken](https://github.com/joyent/node/issues/7161),
        as they use JavaScript's broken `==` equality operator instead of `===`. */
        stats['check-count'] += 1;
        if (CND.equals(...P)) {
          return RH.on_success();
        } else {
          if (P.length === 2) { // and ( CND.isa_text p0 = P[ 0 ] ) and ( CND.isa_text p1 = P[ 1 ] )
            info("string diff:");
            info(diff(rpr(P[0]), rpr(P[1])));
            message = `not equal:\n${CND.white(rpr(P[0]))}\n${CND.yellow(rpr(P[1]))}`;
          } else {
            message = `not equal: ${((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = P.length; i < len; i++) {
                p = P[i];
                results.push(rpr(p));
              }
              return results;
            })()).join(', ')}`;
          }
          return RH.on_error(1, true, new Error(message));
        }
      };
      //-------------------------------------------------------------------------------------------------------
      T.ok = function(result) {
        /* Tests whether `result` is strictly `true` (not only true-ish). */
        stats['check-count'] += 1;
        if (result === true) {
          return RH.on_success();
        } else {
          return RH.on_error(1, true, new Error(`µ67043 not OK: ${rpr(result)}`));
        }
      };
      //-------------------------------------------------------------------------------------------------------
      T.rsvp_ok = function(callback) {
        return (error, ...P) => {
          if (error != null) {
            throw error;
          }
          return callback(...P);
        };
      };
      //-------------------------------------------------------------------------------------------------------
      T.rsvp_error = function(test, callback) {
        return (error, ...P) => {
          this.test_error(test, error);
          return callback(...P);
        };
      };
      //-------------------------------------------------------------------------------------------------------
      T.fail = function(message) {
        /* Fail with message; do not terminate test execution. */
        stats['check-count'] += 1;
        return RH.on_error(1, true, new Error(message));
      };
      //-------------------------------------------------------------------------------------------------------
      T.succeed = function(message) {
        /* Succeed with message; do not terminate test execution. */
        stats['check-count'] += 1;
        help(`succeded: ${message}`);
        return RH.on_success(message);
      };
      //-------------------------------------------------------------------------------------------------------
      T.test_error = function(test, error) {
        var type;
        switch (type = CND.type_of(test)) {
          case 'text':
            return this.eq(error != null ? error['message'] : void 0, test);
          case 'regex':
            return this.ok(test.test(error != null ? error['message'] : void 0));
          case 'function':
            return this.ok(test(error));
        }
        throw new Error(`µ67808 expected a text, a RegEx or a function, got a ${type}`);
      };
      //-------------------------------------------------------------------------------------------------------
      T.throws = function(test, method) {
        var error;
        try {
          // stats[ 'check-count' ] += 1
          method();
        } catch (error1) {
          error = error1;
          return this.test_error(test, error);
        }
        throw new Error("µ68573 expected test to fail with exception, but none was thrown");
      };
      //-------------------------------------------------------------------------------------------------------
      T.check = function(method, callback = null) {
        var R, error, ref;
        try {
          /* TAINT use `callback`? other handler? */
          method(this);
        } catch (error1) {
          error = error1;
          // debug '©x5edC', CND.get_caller_info_stack 0, error, 100, yes
          // debug '©x5edC', CND.get_caller_info 0, error, yes
          RH.on_error(0, false, error);
        }
        // debug '©X5qsy', stats[ 'failures' ][ test_name ]
        R = (ref = stats['failures'][test_name]) != null ? ref : [];
        delete stats['failures'][test_name];
        stats['fail-count'] += -R.length;
        stats['meta-count'] += +R.length;
        if (callback != null) {
          return callback(R);
        } else {
          return R;
        }
      };
      //-------------------------------------------------------------------------------------------------------
      T.perform = async function(probe, matcher, error_pattern, method) {
        var arity, error, message_re, result, stack;
        switch ((arity = arguments.length)) {
          case 3:
            [probe, matcher, error_pattern, method] = [probe, matcher, null, error_pattern];
            break;
          case 4:
            null;
            break;
          default:
            throw new Error(`µ69338 expected 3 or 4 arguments, got ${arity}`);
        }
        if (!is_callable(method)) {
          throw new Error(`µ70103 expected a function, got a ${CND.type_of(method)}`);
        }
        if (error_pattern != null) {
          message_re = new RegExp(error_pattern);
        }
        try {
          result = (await method());
        } catch (error1) {
          error = error1;
          // throw error
          if ((message_re != null) && (message_re.test(error.message))) {
            echo(CND.green(jr([probe, null, error_pattern])));
            this.ok(true);
          } else {
            echo(CND.indigo("µ70868 unexpected exception", jr([probe, null, error.message])));
            stack = (error.stack.split('\n')).slice(1, 6).join('\n');
            this.fail(`µ71633 unexpected exception for probe ${jr(probe)}:\n${error.message}\n${stack}`);
          }
          // whisper 'µ71634', ( error.stack.split '\n' )[ .. 10 ].join '\n'
          // return reject "µ72398 failed with #{error.message}"
          return null;
        }
        if (error_pattern != null) {
          echo(CND.MAGENTA(`${jr([probe, result, null])} #! expected error: ${jr(error_pattern)}`));
          this.fail(`µ73163 expected error, obtained result ${jr(result)}`);
        } else if (CND.equals(result, matcher)) {
          this.ok(true);
          echo(CND.lime(jr([probe, result, null])));
        } else {
          this.fail(`µ73773 neq: result ${jr(result)}, matcher ${jr(matcher)}`);
          echo(CND.red(`${jr([probe, result, null])} #! expected result: ${jr(matcher)}`));
        }
        return result;
      };
      //-------------------------------------------------------------------------------------------------------
      return [RH, T];
    };
    //=========================================================================================================
    // TEST EXECUTION
    //---------------------------------------------------------------------------------------------------------
    run = function() {
      var RH, T, tasks, test, test_name;
      tasks = [];
      if (is_callable(x)) {
        x = {
          test: x
        };
      }
//.......................................................................................................
      for (test_name in x) {
        test = x[test_name];
        if (test_name[0] === '_') {
          continue;
        }
        stats['test-count'] += 1;
        test = test.bind(x);
        [RH, T] = new_result_handler_and_tester(test_name);
        //.....................................................................................................
        ((test_name, test, RH, T) => {
          var arity;
          //...................................................................................................
          switch (arity = test.length) {
            //-------------------------------------------------------------------------------------------------
            // SYNCHRONOUS TESTS
            //-------------------------------------------------------------------------------------------------
            case 1:
              //...............................................................................................
              return tasks.push(function(handler) {
                var error;
                whisper(`started:   ${rpr(test_name)}`);
                try {
                  test(T);
                } catch (error1) {
                  error = error1;
                  RH.on_error(0, false, error);
                }
                whisper(`completed: ${rpr(test_name)}`);
                return handler();
              });
            //-------------------------------------------------------------------------------------------------
            // ASYNCHRONOUS TESTS
            //-------------------------------------------------------------------------------------------------
            case 2:
              //...............................................................................................
              return tasks.push(function(handler) {
                var domain;
                domain = njs_domain.create();
                //.............................................................................................
                domain.on('error', function(error) {
                  RH.on_error(0, false, error);
                  return RH.on_completion(handler);
                });
                //.............................................................................................
                return domain.run(function() {
                  var done, error;
                  done = function(error) {
                    if (error != null) {
                      RH.on_error(0, false, error);
                    }
                    return RH.on_completion(handler);
                  };
                  try {
                    //...........................................................................................
                    return RH.call_with_timeout(settings['timeout'], test, T, done);
                  } catch (error1) {
                    //...........................................................................................
                    error = error1;
                    RH.on_error(0, false, error);
                    return RH.on_completion(handler);
                  }
                });
              });
            default:
              //-------------------------------------------------------------------------------------------------
              throw new Error(`µ73928 expected test with 1 or 2 arguments, got one with ${arity}`);
          }
        })(test_name, test, RH, T);
      }
      //-------------------------------------------------------------------------------------------------------
      return ASYNC.series(tasks, (error) => {
        if (error != null) {
          throw error;
        }
        return report();
      });
    };
    //---------------------------------------------------------------------------------------------------------
    report = function() {
      var entries, entry, fail_count, i, len, pass_count, ref, test_name;
      help("                             --=#=--");
      help("                         GUY TEST REPORT");
      help("                             --=#=--");
      ref = stats['failures'];
      //.......................................................................................................
      for (test_name in ref) {
        entries = ref[test_name];
        help(`test case: ${rpr(test_name)}`);
//.....................................................................................................
        for (i = 0, len = entries.length; i < len; i++) {
          entry = entries[i];
          warn(entry['message']);
          warn('  checked:', entry['checked']);
          warn('  ' + entry['route'] + '#' + entry['line-nr']);
          warn('  ' + entry['source']);
        }
      }
      //.......................................................................................................
      pass_count = stats['pass-count'];
      fail_count = stats['fail-count'];
      info();
      info('tests:   ', stats['test-count']);
      info('checks:  ', stats['check-count']);
      info('metas:   ', stats['meta-count']);
      (fail_count > 0 ? whisper : help)('passes:  ', stats['pass-count']);
      (fail_count > 0 ? warn : whisper)('fails:   ', fail_count);
      return process.exit(fail_count);
    };
    //---------------------------------------------------------------------------------------------------------
    return run();
  };

}).call(this);

//# sourceMappingURL=main.js.map
