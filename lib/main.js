// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, alert, assign, badge, cnd_by_ity, debug, flatten, get_rprs_of_tprs, help, info, isa, isa_type, ity_by_cnd, jr, rpr, urge, warn, whisper,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'INTERTYPE/MAIN';

  debug = CND.get_logger('debug', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  ({assign, jr} = CND);

  flatten = require('lodash/flattenDeep');

  isa_type = Symbol('isa_type');

  this._validation_count = 0;

  //-----------------------------------------------------------------------------------------------------------
  ity_by_cnd = {
    /* ??? */
    // nullorundefined:      'nullorundefined'
    // primitive:            'primitive'
    // symbol:               'symbol'
    /* TAINT object/pod distinction? */
    // object:               'object'
    pod: 'pod',
    boolean: 'boolean',
    buffer: 'buffer',
    function: 'function',
    generator: 'generator',
    // async_function:   'asyncfunction'
    generator_function: 'generatorfunction',
    infinity: 'infinity',
    jsarraybuffer: 'arraybuffer',
    jserror: 'error',
    jsglobal: 'global',
    jsnotanumber: 'nan',
    jsregex: 'regex',
    jsundefined: 'undefined',
    list: 'list',
    null: 'null',
    number: 'number',
    text: 'text'
  };

  // set:                  'set'
  //                 jsarguments:          'jsarguments'
  //                 jsctx:                'jsctx'
  //                 jsdate:               'jsdate'
  //                 jswindow:             'jswindow'
  cnd_by_ity = {};

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.type_of = function(x) {
    var arity, ref, type;
    if ((arity = arguments.length) !== 1) {
      throw new Error(`µ63000 expected 1 argument, got ${arity}`);
    }
    return (ref = ity_by_cnd[type = CND.type_of(x)]) != null ? ref : type;
  };

  //-----------------------------------------------------------------------------------------------------------
  get_rprs_of_tprs = function(tprs) {
    /* `tprs: test parameters, i.e. additional arguments to type tester, as in `multiple_of x, 4` */
    var rpr_of_tprs, srpr_of_tprs;
    rpr_of_tprs = (function() {
      switch (tprs.length) {
        case 0:
          return '';
        case 1:
          return `${rpr(tprs[0])}`;
        default:
          return `${rpr(tprs)}`;
      }
    })();
    srpr_of_tprs = (function() {
      switch (rpr_of_tprs.length) {
        case 0:
          return '';
        default:
          return ' ' + rpr_of_tprs;
      }
    })();
    return {rpr_of_tprs, srpr_of_tprs};
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT must allow additional arguments (as in, `multiple_of x, 5`) */
  this.validate = function(type, message = null) {
    var tester;
    if ((tester = this[type]) == null) {
      throw new Error(`µ63077 unknown type ${rpr(type)}`);
    }
    return (x, ...tprs) => {
      /* TAINT code duplication */
      var error, prv_message, result, rpr_of_tprs, srpr_of_tprs;
      prv_message = '';
      try {
        result = tester(x, ...tprs);
      } catch (error1) {
        error = error1;
        prv_message = error.message + '\n';
      }
      // @_stop_validating()
      if (!result) {
        ({rpr_of_tprs, srpr_of_tprs} = get_rprs_of_tprs(tprs));
        if (message != null) {
          message = message.replace(/\$type/g, type);
          message = message.replace(/\$value/g, rpr(x));
          message = message.replace(/\$tprs/g, rpr_of_tprs);
          message = message.replace(/\$stprs/g, srpr_of_tprs);
        } else {
          message = `µ63154 expected a ${type}, got a ${CND.type_of(x)}${srpr_of_tprs} (value: ${rpr(x)})`;
        }
        throw new Error(prv_message + message);
      }
      return null;
    };
  };

  //===========================================================================================================
  // ADDING TYPES
  //-----------------------------------------------------------------------------------------------------------
  this.add_type = function(type, settings, tester) {
    var _type, arity, defaults, ref, ref1;
    switch ((arity = arguments.length)) {
      case 2:
        [type, settings, tester] = [type, null, settings];
        break;
      case 3:
        null;
        break;
      default:
        throw new Error(`µ29892 expected 2 or 3 arguments, got ${arity}`);
    }
    defaults = {
      overwrite: false,
      size_of: (ref = (ref1 = settings != null ? settings.size_of : void 0) != null ? ref1 : this._registry_for_size_of[type]) != null ? ref : null
    };
    settings = settings != null ? assign({}, settings, defaults) : defaults;
    //.........................................................................................................
    if (!(_type = CND.isa_text(type))) {
      throw new Error(`µ33988 expected a text for type, got a ${rpr(_type)}`);
    }
    if (!(_type = CND.isa_function(tester))) {
      throw new Error(`µ33988 expected a function for tester, got a ${rpr(_type)}`);
    }
    //.........................................................................................................
    if ((!settings.overwrite) && (this[type] !== void 0)) {
      throw new Error(`name ${rpr(type)} already defined`);
    }
    //.........................................................................................................
    tester = tester.bind(this);
    //.........................................................................................................
    /* Add type tester method: */
    this[type] = (x, ...tprs) => {
      /* TAINT code duplication */
      var R, rpr_of_tprs, srpr_of_tprs;
      R = tester(x, ...tprs);
      if ((!R) && (this._validation_count > 0)) {
        ({rpr_of_tprs, srpr_of_tprs} = get_rprs_of_tprs(tprs));
        throw new Error(`µ11111 not a valid ${type}${srpr_of_tprs}: ${rpr(x)}`);
      }
      return R;
    };
    this[type][isa_type] = true;
    //.........................................................................................................
    /* Add type validator method: */
    this.validate[type] = (x, ...P) => {
      this._validation_count += +1;
      try {
        (this.validate(type))(x, ...P);
      } finally {
        // catch error then debug "µ23272 >>>>>>>>>>>>>> value #{rpr x}"; throw error
        this._validation_count += -1;
      }
      return null;
    };
    //.........................................................................................................
    /* Add type size method: */
    ((s) => {
      var type_of_s;
      if (s === null) {
        return this._registry_for_size_of[type] = null;
      } else {
        switch (type_of_s = this.type_of(s)) {
          case 'text':
            return this._registry_for_size_of[type] = function(x) {
              return x[s];
            };
          case 'function':
            return this._registry_for_size_of[type] = s;
          default:
            throw new Error(`µ30988 expected null, a text or a function for size_of, got a ${type_of_s}`);
        }
      }
    })(settings.size_of);
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // SUB- AND SUPERTYPES
  //-----------------------------------------------------------------------------------------------------------
  this.extensions = {
    function: 'callable',
    boundfunction: 'callable',
    generatorfunction: 'callable',
    asyncfunction: 'callable',
    safe_integer: 'integer',
    integer: 'number',
    float: 'number'
  };

  //-----------------------------------------------------------------------------------------------------------
  this.extends = function(subtype, supertype) {
    var arity, type;
    if ((arity = arguments.length) !== 2) {
      /* TAINT use validation functions with arguments */
      throw new Error(`µ63231 expected 2 arguments, got ${arity}`);
    }
    if ((type = this.type_of(subtype)) !== 'text') {
      throw new Error(`µ63308 expected a text, got a ${type}`);
    }
    if ((type = this.type_of(supertype)) !== 'text') {
      throw new Error(`µ63385 expected a text, got a ${type}`);
    }
    if (subtype === supertype) {
      return true;
    }
    return (this.extensions[subtype] === supertype) || (this.extends(this.extensions[subtype], supertype));
  };

  //-----------------------------------------------------------------------------------------------------------
  this.supertype_of = function(x) {
    return this.supertype_of_type(this.type_of(x));
  };

  //-----------------------------------------------------------------------------------------------------------
  this.supertype_of_type = function(type) {
    var supertype;
    if ((supertype = this.extensions[type]) == null) {
      return type;
    }
    return this.supertype_of_type(supertype);
  };

  //===========================================================================================================
  // OBJECT SIZES
  //-----------------------------------------------------------------------------------------------------------
  /* TAINT in lieu of `@_registry_for_size_of`, set up a type metadata registry that includes other info
  such as sub/supertypes, whether type represents an indexed and ordered collection, etc. */
  this._registry_for_size_of = {
    list: 'length',
    // arguments:  'length'
    buffer: 'length',
    set: 'size',
    map: 'size',
    //.........................................................................................................
    global: (x) => {
      return (this.all_keys_of(x)).length;
    },
    pod: (x) => {
      return (this.keys_of(x)).length;
    },
    //.........................................................................................................
    text: function(x, selector = 'codeunits') {
      var ref;
      switch (selector) {
        case 'codepoints':
          return (Array.from(x)).length;
        case 'codeunits':
          return x.length;
        case 'bytes':
          return Buffer.byteLength(x, (ref = typeof settings !== "undefined" && settings !== null ? settings['encoding'] : void 0) != null ? ref : 'utf-8');
        default:
          throw new Error(`unknown counting selector ${rpr(selector)}`);
      }
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this.size_of = function(x, ...P) {
    var getter, type;
    /* The `size_of()` method uses a per-type configurable methodology to return the size of a given value;
    such methodology may permit or necessitate passing additional arguments (such as `size_of text`, which
    comes in several flavors depending on whether bytes or codepoints are to be counted). As such, it is a
    model for how to implement Go-like method dispatching. */
    // debug 'µ44744', [ x, P, ]
    type = CND.type_of(x);
    if (!(this.function((getter = this._registry_for_size_of[type])))) {
      throw new Error(`µ88793 unable to get size of a ${type}`);
    }
    return getter(x, ...P);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.first_of = function(collection) {
    return collection[0];
  };

  this.last_of = function(collection) {
    return collection[collection.length - 1];
  };

  //-----------------------------------------------------------------------------------------------------------
  this.arity_of = function(x) {
    var type;
    if ((type = this.supertype_of(x)) !== 'callable') {
      throw new Error(`µ88733 expected a callable, got a ${type}`);
    }
    return x.length;
  };

  //===========================================================================================================
  // OBJECT PROPERTY CATALOGUING
  //-----------------------------------------------------------------------------------------------------------
  this.keys_of = function(...P) {
    return this.values_of(this.walk_keys_of(...P));
  };

  this.all_keys_of = function(...P) {
    return this.values_of(this.walk_all_keys_of(...P));
  };

  this.all_own_keys_of = function(x) {
    if (x != null) {
      return Object.getOwnPropertyNames(x);
    } else {
      return [];
    }
  };

  this.walk_all_own_keys_of = function*(x) {
    var i, k, len, ref, results;
    ref = this.all_own_keys_of(x);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      results.push((yield k));
    }
    return results;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.walk_keys_of = function*(x, settings) {
    var defaults, k, results;
    defaults = {
      skip_undefined: true
    };
    settings = settings != null ? assign({}, settings, defaults) : defaults;
    results = [];
    for (k in x) {
      if ((x[k] === void 0) && settings.skip_undefined) {
        /* TAINT should use property descriptors to avoid possible side effects */
        continue;
      }
      results.push((yield k));
    }
    return results;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.walk_all_keys_of = function(x, settings) {
    var defaults;
    defaults = {
      skip_object: true,
      skip_undefined: true
    };
    settings = settings != null ? assign({}, settings, defaults) : defaults;
    return this._walk_all_keys_of(x, new Set(), settings);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_all_keys_of = function*(x, seen, settings) {
    /* TAINT should use property descriptors to avoid possible side effects */
    /* TAINT trying to access `arguments` causes error */
    var error, k, proto, ref, value;
    if ((!settings.skip_object) && x === Object.prototype) {
      return;
    }
    ref = this.walk_all_own_keys_of(x);
    //.........................................................................................................
    for (k of ref) {
      if (seen.has(k)) {
        continue;
      }
      seen.add(k);
      try {
        value = x[k];
      } catch (error1) {
        error = error1;
        continue;
      }
      if ((value === void 0) && settings.skip_undefined) {
        continue;
      }
      if (settings.symbol != null) {
        if (value == null) {
          continue;
        }
        if (!value[settings.symbol]) {
          continue;
        }
      }
      yield k;
    }
    //.........................................................................................................
    if ((proto = Object.getPrototypeOf(x)) != null) {
      return (yield* this._walk_all_keys_of(proto, seen, settings));
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  /* Turn iterators into lists, copy lists: */
  this.values_of = function(x) {
    return [...x];
  };

  //-----------------------------------------------------------------------------------------------------------
  this.has_keys = function(x, ...P) {
    var i, key, len, ref;
    if (x == null) {
      /* Observe that `has_keys()` always considers `undefined` as 'not set' */
      return false;
    }
/* TAINT or throw error */    ref = flatten(P);
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (x[key] === void 0) {
        /* TAINT should use property descriptors to avoid possible side effects */
        return false;
      }
    }
    return true;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.has_only_keys = function(x, ...P) {
    var keys, probes;
    probes = (flatten(P)).sort();
    keys = (this.values_of(this.keys_of(x))).sort();
    return CND.equals(probes, keys);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.known_types = function() {
    return [
      ...(this.walk_all_keys_of(this,
      {
        symbol: isa_type
      }))
    ];
  };

  //===========================================================================================================
  // THE `ISA()` METHOD
  //-----------------------------------------------------------------------------------------------------------
  isa = function(x, type) {
    var arity, tester;
    if ((arity = arguments.length) === 1) {
      return this.type_of(x);
    }
    if (arity !== 2) {
      throw new Error(`µ63462 expected 2 arguments, got ${arity}`);
    }
    if ((type = this.type_of(type)) !== 'text') {
      throw new Error(`µ63539 expected a text, got a ${type}`);
    }
    if ((tester = this[type]) == null) {
      throw new Error(`µ63616 unknown type ${rpr(type)}`);
    }
    return tester(x);
  };

  //###########################################################################################################
  // ASSEMBLY
  //===========================================================================================================
  isa = isa.bind(this);

  module.exports = isa;

  (() => {
    var cnd_key, cnd_method, cnd_type, ity_type, key, ref, ref1, size_of, type, value;
//---------------------------------------------------------------------------------------------------------
    for (cnd_type in ity_by_cnd) {
      ity_type = ity_by_cnd[cnd_type];
      /* Generate entries to cnd_by_ity: */
      if (cnd_by_ity[ity_type] != null) {
        throw new Error(`µ49833 name collision in cnd_by_ity: ${rpr(ity_type)}`);
      }
      cnd_by_ity[ity_type] = cnd_type;
    }
    ref = this;
    //---------------------------------------------------------------------------------------------------------
    /* Bind all functions to `module.exports`: */
    for (key in ref) {
      value = ref[key];
      /* TAINT use isa.callable */
      if (CND.isa_function(value)) {
        isa[key] = value.bind(isa);
      } else {
        isa[key] = value;
      }
    }
//---------------------------------------------------------------------------------------------------------
    for (cnd_type in ity_by_cnd) {
      ity_type = ity_by_cnd[cnd_type];
      if (this[ity_type] != null) {
        /* Generate mappings from `isa.$type()` to CND.isa_$type()`: */
        continue;
      }
      cnd_key = `isa_${cnd_type}`;
      // debug 'µ8498', cnd_type, ity_type, cnd_key, CND.type_of CND[ cnd_key ]
      if ((type = CND.type_of((cnd_method = CND[cnd_key]))) !== 'function') {
        throw new Error(`µ63693 expected a function for \`CND.${cnd_key}\`, found a ${type}`);
      }
      size_of = (ref1 = this._registry_for_size_of[ity_type]) != null ? ref1 : null;
      isa.add_type(ity_type, {size_of}, cnd_method.bind(CND));
    }
    //---------------------------------------------------------------------------------------------------------
    return null;
  })();

  //===========================================================================================================
  // ADDITIONAL TYPES
  //-----------------------------------------------------------------------------------------------------------
  isa.add_type('set', {
    size_of: 'size'
  }, function(x) {
    return (Object.prototype.toString.call(x)) === '[object Set]';
  });

  isa.add_type('map', {
    size_of: 'size'
  }, function(x) {
    return (Object.prototype.toString.call(x)) === '[object Map]';
  });

  isa.add_type('weakmap', {
    size_of: null
  }, function(x) {
    return (Object.prototype.toString.call(x)) === '[object WeakMap]';
  });

  isa.add_type('weakset', {
    size_of: null
  }, function(x) {
    return (Object.prototype.toString.call(x)) === '[object WeakSet]';
  });

  //-----------------------------------------------------------------------------------------------------------
  isa.add_type('integer', Number.isInteger);

  isa.add_type('finite_number', Number.isFinite);

  isa.add_type('safe_integer', Number.isSafeInteger);

  isa.add_type('count', function(x) {
    return (this.safe_integer(x)) && (x >= 0);
  });

  isa.add_type('asyncfunction', function(x) {
    return (this.type_of(x)) === 'asyncfunction';
  });

  isa.add_type('boundfunction', function(x) {
    return ((this.supertype_of(x)) === 'callable') && (!Object.hasOwnProperty(x, 'prototype'));
  });

  isa.add_type('callable', function(x) {
    var ref;
    return (ref = this.type_of(x)) === 'function' || ref === 'asyncfunction' || ref === 'generatorfunction';
  });

  isa.add_type('positive', function(x) {
    return (this.number(x)) && (x > 0);
  });

  isa.add_type('negative', function(x) {
    return (this.number(x)) && (x < 0);
  });

  // isa.add_type 'positive0',     ( x ) -> ( @number x ) and ( x >= 0 )
  // isa.add_type 'negative0',     ( x ) -> ( @number x ) and ( x <= 0 )
  isa.add_type('nonnegative', function(x) {
    return (this.number(x)) && (x >= 0);
  });

  isa.add_type('even', function(x) {
    return (this.finite_number(x)) && this.multiple_of(x, 2);
  });

  isa.add_type('odd', function(x) {
    return (this.finite_number(x)) && !this.multiple_of(x, 2);
  });

  isa.add_type('multiple_of', function(x, d) {
    return (this.finite_number(x)) && (modulo(x, d)) === 0;
  });

  isa.add_type('empty', function(x) {
    return (this.size_of(x)) === 0;
  });

  isa.add_type('nonempty', function(x) {
    return (this.size_of(x)) > 0;
  });

}).call(this);

//# sourceMappingURL=main.js.map
